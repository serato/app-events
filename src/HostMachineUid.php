<?php

declare(strict_types=1);

namespace Serato\AppEvents;

use Serato\AppEvents\Exception\InvalidHostMachineUidException;

/**
 * ** HostMachineUid **
 *
 * Provides functionality for handling host IDs generated by client software applications.
 *
 * * Host ID format *
 *
 * There are two different host ID formats is use: one that's used by Serato DJ, and another
 * that's used by Serato Studio and Serato Sample.
 *
 * These formats are referred to as `Host ID` and `Host ID Extended` respectively.
 *
 * Some rules that apply to both host ID formats:
 *
 * - System IDs may start with a manufacturer ID. This ID is max. 4 bytes and may contain non-ASCII characters.
 * - Storage IDs are not required. ie. They may be empty (yes, seriously).
 * - Storage IDs are not necessarily unique within a single host ID
 * - Storage IDs contain only ASCII characters
 *
 * Host ID examples of the same host with different storage devices attached as generated by
 * each format:
 *
 * `Host ID` format (as used by Serato DJ)
 *
 * P57TL8GGQI69~GBFUL623C0UIG                                           # SystemId~StorageId0
 * P57TL8GGQI69~PG796169S564N489                                        # SystemId~StorageId1
 * P57TL8GGQI69~PG796169S564N489~GBFUL623C0UIG                          # SystemId~StorageId1~StorageId0
 * P57TL8GGQI69~GBFUL623C0UIG~PG796169S564N489                          # SystemId~StorageId0~StorageId1
 *
 * `Host ID Extended` format (as used by Studio and Sample)
 *
 * SID=P57TL8GGQI69~GBFUL623C0UIG                                       # SystemId~StorageId0
 * SID=P57TL8GGQI69~PG796169S564N489                                    # SystemId~StorageId1
 * SID=P57TL8GGQI69~GBFUL623C0UIG SID=P57TL8GGQI69~PG796169S564N489     # SystemId~StorageId1 SystemId~StorageId0
 * SID=P57TL8GGQI69~PG796169S564N489 SID=P57TL8GGQI69~GBFUL623C0UIG     # SystemId~StorageId0 SystemId~StorageId1
 */
class HostMachineUid
{
    private const FIELD_DELIMITER = '~';
    private const HOSTIDEXTENDED_SYSTEM_ID_PREFIX = 'SID=';
    private const EMPTY_STORAGEID_PLACEHOLDER = 'EMPTY_STORAGE_ID';

    /** @var string */
    private $str = '';

    /** @var string */
    private $systemId = '';

    /** @var array */
    private $storageIds = [];

    /** @var bool */
    private $isExtended = true;

    public function __construct(string $hostId)
    {
        $this->str = $hostId;
        $this->parse($hostId);
    }

    /**
     * Returns the original raw host ID
     *
     * @return string
     */
    public function __toString(): string
    {
        return $this->str;
    }

    /**
     * Returns a string representation of the host ID.
     *
     * Can optionally specify a maximum string length via the `$length` parameter. A limited number
     * of storage IDs will be returned such that the overall string does not exceed the specified length.
     *
     * At least one storage ID will be returned even if the `$length` parameter is provided (ie. length
     * limitations only apply when there is more than one storage ID).
     *
     * Can also optionally allow for specifying that an `Host ID Extended` format string is returned.
     * If not specified, the original format of the raw host ID is used.
     *
     * @param integer|null $length      Specifies maximum host ID length.
     *                                  The full host ID will be returned if not provided.
     * @param boolean|null $extended    Specifies that the host ID is returned in `Host ID Extended` format.
     * @return string
     */
    public function get(?int $length = null, ?bool $extended = null): string
    {
        $formatToExtended = $this->isExtended;
        if ($extended !== null) {
            $formatToExtended = $extended;
        }

        if ($formatToExtended) {
            return $this->getExtendedHostIdString($this->getStorageIds(), $length);
        } else {
            return $this->getHostIdString($this->getStorageIds(), $length);
        }
    }

    /**
     * Returns a canonical form of a host id.
     *
     * The canonical form used the `Host ID` format and provides strict ordering
     * of the storage IDs. ie. The canonical form will always be the same irrespective
     * of the ordering of the storage IDs in the raw host ID.
     *
     * @return string
     */
    public function getCanonicalHostId(): string
    {
        $storageIds = $this->getStorageIds();
        sort($storageIds, SORT_STRING);
        return $this->getHostIdString($storageIds, null);
    }

    /**
     * Returns a host ID string in `Host ID Extended` format
     *
     * @param array $storageIds
     * @param integer|null $length
     * @return string
     */
    private function getExtendedHostIdString(array $storageIds, ?int $length): string
    {
        $joinStr = self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX . $this->getSystemId() . self::FIELD_DELIMITER;
        $hostId = str_replace(
            self::EMPTY_STORAGEID_PLACEHOLDER,
            '',
            $joinStr . implode(' ' . $joinStr, $storageIds)
        );
        if ($length !== null) {
            # Always include at least one storage ID, even if the string limit is exceeded
            while (strlen($hostId) > $length && substr_count($hostId, ' ') > 0) {
                if (strrpos($hostId, ' ') !== false) {
                    $hostId = substr($hostId, 0, strrpos($hostId, ' '));
                }
            }
        }
        return $hostId;
    }

    /**
     * Returns a host ID string in `Host ID` format
     *
     * @param array $storageIds
     * @param integer|null $length
     * @return string
     */
    private function getHostIdString(array $storageIds, ?int $length): string
    {
        $hostId = str_replace(
            self::EMPTY_STORAGEID_PLACEHOLDER,
            '',
            $this->systemId . self::FIELD_DELIMITER . implode(self::FIELD_DELIMITER, $storageIds)
        );
        if ($length !== null) {
            # Always include at least one storage ID, even if the string limit is exceeded
            while (strlen($hostId) > $length && substr_count($hostId, self::FIELD_DELIMITER) > 1) {
                if (strrpos($hostId, self::FIELD_DELIMITER) !== false) {
                    $hostId = substr($hostId, 0, strrpos($hostId, self::FIELD_DELIMITER));
                }
            }
        }
        return $hostId;
    }

    /**
     * Compare two host ids and check if they match the comparison policy:
     * - System ID must match
     * - At least one storage ID must match
     *
     * @param self $hostMachineId   HostMachineUid instance to compare against
     *
     * @return bool     Indicates whether the HostMachineUids match
     */
    public function match(self $hostMachineId): bool
    {
        # TODO (maybe)
        #
        # Host software applications and the My Serato window do more than just a straight string
        # comparison on storage IDs: if the storage ID strings don't match they swap bytes within
        # the string and re-compare.
        #
        # I *think* this was a fix for a Windows version that, for whatever reason, generated a
        # different host ID for the same device as a previous version of Windows.
        #
        # This logic is NOT implemented here but could be added later if need be.

        // Confirm that the system IDs match
        if (
            strcmp($this->getSystemId(), $hostMachineId->getSystemId()) !== 0 ||
            count(array_intersect($this->getStorageIds(), $hostMachineId->getStorageIds())) === 0
        ) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Returns a new instance
     *
     * @param string $hostId
     * @return self
     */
    public static function create(string $hostId): self
    {
        return new self($hostId);
    }

    /**
     * Parses a host ID
     *
     * @param string $hostId
     * @return void
     */
    private function parse(string $hostId): void
    {
        if (strpos($hostId, self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX) === 0) {
            $this->parseHostIdExtended($hostId);
        } else {
            $this->parseHostId($hostId);
            $this->isExtended = false;
        }
    }

    /**
     * Parses a host ID generated by an application that uses the `Host ID` format
     *
     * @param string $hostId
     * @return void
     *
     * @throws InvalidHostMachineUidException
     */
    private function parseHostId(string $hostId): void
    {
        $this->systemId = '';
        $this->storageIds = [];

        # Host ID cannot start with self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX ("SID=") and
        # must contain at least one self::FIELD_DELIMITER character ("~")
        if (
            strpos($hostId, self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX) === 0 ||
            count(explode(self::FIELD_DELIMITER, $hostId)) < 2
        ) {
            throw new InvalidHostMachineUidException(
                'Host ID "' . $hostId . '" does not conform to `Host ID` requirements. ' .
                'A `Host ID` cannot start with "' . self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX .
                '" and must contain at one "' . self::FIELD_DELIMITER . '" character.'
            );
        }

        $sections = explode(self::FIELD_DELIMITER, $hostId);
        $this->setSystemId(array_shift($sections) ?? '');

        foreach ($sections as $section) {
            if ($section === $this->getSystemId()) {
                throw new InvalidHostMachineUidException(
                    'Host ID "' . $hostId . '" does not conform to `Host ID` requirements. ' .
                    'System IDs must be unique within a host ID.'
                );
            } else {
                # Storage ID can legitimately be empty string. In this case the self::match function
                # is expected to match on the emptyness.
                # So store a placeholder string so that represents the missing storage ID.
                if ($section === '') {
                    $section = self::EMPTY_STORAGEID_PLACEHOLDER;
                }

                $this->addStorageId($section);
            }
        }
    }

    /**
     * Parses a host ID generated by an application that uses the `Host ID Extended` format
     *
     * @param string $hostId
     * @return void
     *
     * @throws InvalidHostMachineUidException
     */
    private function parseHostIdExtended(string $hostId): void
    {
        $this->systemId = '';
        $this->storageIds = [];

        # Host ID must start with self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX ("SID=") and
        # must contain at least one self::FIELD_DELIMITER character ("~")
        if (
            strpos($hostId, self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX) !== 0 ||
            count(explode(self::FIELD_DELIMITER, $hostId)) < 2
        ) {
            throw new InvalidHostMachineUidException(
                'Host ID "' . $hostId . '" does not conform to `Host ID Extended` requirements. ' .
                'A `Host ID Extended` must start with "' . self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX .
                '" and must contain at one "' . self::FIELD_DELIMITER . '" character.'
            );
        }

        foreach (explode(self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX, $hostId) as $section) {
            $section = trim($section);
            if ($section !== '') {
                # Should be an array with two items: [0] = system ID, [1] = storage ID
                $systemStoragePair = explode(self::FIELD_DELIMITER, $section);

                if (count($systemStoragePair) !== 2) {
                    throw new InvalidHostMachineUidException(
                        'Host ID "' . $hostId . '" does not conform to `Host ID Extended` requirements. ' .
                        'Each "' . self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX .
                        '"-delimited section must contain only a single "' .
                        self::FIELD_DELIMITER . '" character denoting a system ID / storage ID pair.'
                    );
                }

                # System ID must the same for every section
                if (!$this->setSystemId($systemStoragePair[0])) {
                    throw new InvalidHostMachineUidException(
                        'Host ID "' . $hostId . '" does not conform to `Host ID Extended` requirements. ' .
                        'Each "' . self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX .
                        '"-delimited system ID / storage ID pair must ' .
                        'have the same system ID.'
                    );
                }

                # Can't have the system ID present where the storage ID should be
                if ($this->getSystemId() === $systemStoragePair[1]) {
                    throw new InvalidHostMachineUidException(
                        'Host ID "' . $hostId . '" does not conform to `Host ID Extended` requirements. ' .
                        'System ID is duplicated in storage ID data section.'
                    );
                }

                # Storage ID can legitimately be empty string. In this case the self::match function
                # is expected to match on the emptyness.
                # So store a placeholder string so that represents the missing storage ID.
                if ($systemStoragePair[1] === '') {
                    $systemStoragePair[1] = self::EMPTY_STORAGEID_PLACEHOLDER;
                }

                $this->addStorageId($systemStoragePair[1]);
            }
        }
    }

    /**
     * Returns the system ID
     *
     * @return string
     */
    public function getSystemId(): string
    {
        return $this->systemId;
    }

    /**
     * Returns an array of all storage IDs
     *
     * @return array
     */
    public function getStorageIds(): array
    {
        return $this->storageIds;
    }

    /**
     * Sets the system ID.
     *
     * Will return `true` if system ID has not previously been set
     * or is being re-set to the current value.
     *
     * Will return `false` if system ID is currently set and the new
     * value does not match the current value.
     *
     * @param string $systemId
     * @return boolean
     */
    private function setSystemId(string $systemId): bool
    {
        if ($this->systemId === '' || $this->systemId === $systemId) {
            $this->systemId = $systemId;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Adds a storage ID.
     *
     * Returns `true` if the storage ID has not previosly been set, otherwise `false`.
     *
     * @param string $storageId
     * @return boolean
     */
    private function addStorageId(string $storageId): bool
    {
        if (in_array($storageId, $this->storageIds)) {
            return false;
        } else {
            $this->storageIds[] = $storageId;
            return true;
        }
    }
}
